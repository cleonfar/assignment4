---
timestamp: 'Thu Oct 16 2025 01:55:52 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_015552.44804ffd.md]]'
content_id: 2d980f87ee0c6034700f717e81fb1f5f590f77263f120be1ae9ee417ecfc01db
---

# concept ReproductionTracking

* **purpose** track reproductive outcomes and offspring survivability for breeding animals

* **principle**
  a user records birth events for mother animals, optionally linking fathers and offspring;
  later records weaning outcomes for those offspring when the data becomes available;
  uses this data to generate reports to evaluate reproductive performance and inform breeding decisions;
  can choose to generate an AI summary of generated reports to aide in understanding and decision making;

* **state**
  * a set of `mothers` with
    * an `ID` of type `ID`
    * an optional `notes` of type `String`
    * a set of `litter`

  * a set of `litter` with
    * a `litterSize` of type `number`
    * a `birthDate` of type `date`
    * a set of `offspring`

  * a set of `offspring` with
    * an `ID` of type `ID`
    * an optional `father` of type `ID`
    * a `birthDate` of type `Date`
    * a `sex` of type `Enum [male, female, neutered]`
    * a `countBorn` of type `Number`
    * an optional `notes` of type `String`
    * a `status` of type `Bool`
    * a `survivedTillWeaning` of type `Bool`

  * a set of `GeneratedReports` with
    * a `report name` of type `String`
    * a `dateGenerated` of type `Date`
    * a `target` of type `Set<ID>`
    * a set of `results` of type `(key-value pairs or tabular data)`

* **actions**:
  * `addMother (mother: ID): (mother: ID)`
    * **requires** mother is not already in the set of mothers
    * **effects** mother is added to the set of mothers

  * `removeMother (mother: ID): (mother: ID)`
    * **requires** a mother with this ID is in the set of mothers
    * **effects** removes this mother from the set of mothers

  * `recordBirth (mother: ID, father: ID?, birthDate: Date, offspring: ID, countBorn: Number, sex: Enum [male, female, neutered], notes: String?): (offspring: Offspring)`
    * **effects** creates an offspring with the given information, adds it to an existing litter and increments the litter size if the given mother has a litter with that birth date already otherwise creates a new litter.

  * `updateBirth (offspring: ID, birthDate: Date?, father: ID?, mother: ID?, countBorn: Number?, sex: Enum?, notes: String?): (offspring: Offspring)`
    * **requires** There is an offspring with the given ID
    * **effects** Updates any given information about the offspring's birth. If the mother is changed, move the offspring to the new mother's set off offspring, adding the mother to the set of mothers if necessary.

  * `recordWeaning (offspring: ID): offspring: ID`
    * **requires** offspring is in the set of offspring and is alive
    * **effects** Sets survived until weaning to be true

  * `recordDeath (offspring: ID): (offspring: ID)`
    * **requires** offspring is in the set of offspring and is currently living
    * **effects** Sets the alive flag of this offspring to false

  * `viewOffspring (mother: ID): (offspring: Set<offspring>)`
    * **requires** animal exists
    * **effects** return the IDs of all offspring

  * `generateReport (target: Set<ID>, startDateRange: Date, endDateRange: Date, name: String?): (report: GeneratedReport)`
    * **requires** All target animals are in the set of mothers
    * **effects** produce a report on the reproductive performance of the given animals within the specified date range

  * `renameReport (oldName: String, newName: String): (report: GeneratedReport)`
    * **requires** oldName of report exists
    * **effects** produce a report on the reproductive performance of the given animals within the specified date range

  * `viewReport (report: GeneratedReport): (results: GeneratedReport)`
    * **requires** report exists
    * **effects** return the summary and results of the report

  * `listReports (): (reports: Set<GeneratedReport>)`
    * **effects** return all generated reports

  * `deleteReport (report: String)`
    * **requires** report exists
    * **effects** remove the report from the system

  * `aiSummary (report: Report): (summary: String)`
    * **requires** report exists
    * **effects** The ai takes the report and gives a summary of the report, highlighting key\
      takeaways and trends shown in the report.

```typescript
// file: src/ReproductionTracking/ReproductionTrackingConcept.ts
import { Collection, Db } from "npm:mongodb"; // Removed ModifyResult, as it's not the direct return type here
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "ReproductionTracking" + ".";

/**
 * Enum for the sex of an offspring.
 */
export enum Sex { // Exported for external use in syncs or tests
  Male = "male",
  Female = "female",
  Neuter = "neutered", // Using 'Neuter' to avoid clash with 'neutered' as a verb
}

/**
 * Represents a mother animal in the system.
 *
 * **state**: a set of `mothers` with
 *   - an `ID` of type `ID`
 *   - an optional `notes` of type `String`
 */
interface Mother {
  _id: ID;
  notes?: string;
}

/**
 * Represents an offspring animal.
 *
 * **state**: a set of `offspring` with
 *   - an `ID` of type `ID`
 *   - an optional `father` of type `ID`
 *   - a `birthDate` of type `Date`
 *   - a `sex` of type `Enum [male, female, neutered]`
 *   - a `countBorn` of type `Number`
 *   - an optional `notes` of type `String`
 *   - a `status` of type `Bool` (interpreted as `isAlive`)
 *   - a `survivedTillWeaning` of type `Bool`
 */
interface Offspring {
  _id: ID;
  motherId: ID; // Link to the mother animal
  fatherId?: ID;
  birthDate: Date;
  sex: Sex;
  countBorn: number; // Number of offspring born in this specific birth event (e.g., litter size)
  notes?: string;
  isAlive: boolean; // Renamed from 'status' for clarity on state
  survivedTillWeaning: boolean;
}

/**
 * Represents a generated report.
 *
 * **state**: a set of `GeneratedReports` with
 *   - a `report name` of type `String`
 *   - a `dateGenerated` of type `Date`
 *   - a `target` of type `Set<ID>`
 *   - a set of `results` of type `(key-value pairs or tabular data)`
 */
interface GeneratedReport {
  _id: ID;
  reportName: string;
  dateGenerated: Date;
  target: ID[]; // Set of mother IDs this report covers
  results: Record<string, any>; // Flexible structure for report data
}

/**
 * **concept** ReproductionTracking
 *
 * **purpose** track reproductive outcomes and offspring survivability for breeding animals
 *
 * **principle**
 *   a user records birth events for mother animals, optionally linking fathers and offspring;
 *   later records weaning outcomes for those offspring when the data becomes available;
 *   uses this data to generate reports to evaluate reproductive performance and inform breeding decisions;
 *   can choose to generate an AI summary of generated reports to aide in understanding and decision making;
 */
export default class ReproductionTrackingConcept {
  private mothers: Collection<Mother>;
  private offspring: Collection<Offspring>;
  private generatedReports: Collection<GeneratedReport>;

  constructor(private readonly db: Db) {
    this.mothers = this.db.collection(PREFIX + "mothers");
    this.offspring = this.db.collection(PREFIX + "offspring");
    this.generatedReports = this.db.collection(PREFIX + "generatedReports");
  }

  /**
   * **action** `addMother (mother: ID): (mother: ID)`
   *
   * **requires** mother is not already in the set of mothers
   * **effects** mother is added to the set of mothers
   */
  async addMother({ motherId }: { motherId: ID }): Promise<{ motherId?: ID; error?: string }> {
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (existingMother) {
      return { error: `Mother with ID ${motherId} already exists.` };
    }

    const newMother: Mother = { _id: motherId };
    await this.mothers.insertOne(newMother);
    return { motherId };
  }

  /**
   * **action** `removeMother (mother: ID): (mother: ID)`
   *
   * **requires** a mother with this ID is in the set of mothers
   * **effects** removes this mother from the set of mothers. Offspring previously linked to this mother
   *            will remain in the system but their `motherId` will point to a non-existent record.
   */
  async removeMother({ motherId }: { motherId: ID }): Promise<{ motherId?: ID; error?: string }> {
    const result = await this.mothers.deleteOne({ _id: motherId });
    if (result.deletedCount === 0) {
      return { error: `Mother with ID ${motherId} not found.` };
    }
    return { motherId };
  }

  /**
   * **action** `recordBirth (mother: ID, father: ID?, birthDate: Date, offspring: ID, countBorn: Number, sex: Enum [male, female, neutered], notes: String?): (offspring: Offspring)`
   *
   * **effects** adds the recorded offspring to the set of offspring. Also adds the mother to the set of mothers if she isn't there already
   */
  async recordBirth(
    { motherId, fatherId, birthDate, offspringId, countBorn, sex, notes }:
      { motherId: ID; fatherId?: ID; birthDate: Date; offspringId: ID; countBorn: number; sex: Sex; notes?: string },
  ): Promise<{ offspring?: Offspring; error?: string }> {
    // Add mother if she doesn't exist already
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (!existingMother) {
      // Intentionally ignoring the result/error of addMother here, assuming it will either succeed
      // or a critical database error will be thrown naturally.
      await this.addMother({ motherId });
    }

    // Check if offspring ID already exists to prevent duplicates
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (existingOffspring) {
      return { error: `Offspring with ID ${offspringId} already exists.` };
    }

    const newOffspring: Offspring = {
      _id: offspringId, // Use the provided offspringId as the primary key
      motherId,
      fatherId,
      birthDate: new Date(birthDate), // Ensure `birthDate` is a Date object
      sex,
      countBorn,
      notes,
      isAlive: true, // Default to alive at birth
      survivedTillWeaning: false, // Default to not yet weaned
    };

    await this.offspring.insertOne(newOffspring);
    return { offspring: newOffspring };
  }

  /**
   * **action** `updateBirth (offspring: ID, birthDate: Date?, father: ID?, mother: ID?, countBorn: Number?, sex: Enum?, notes: String?): (offspring: Offspring)`
   *
   * **requires** There is an offspring with the given ID
   * **effects** Updates any given information about the offspring's birth. If the mother is changed,
   *            the offspring's `motherId` is updated, and the new mother is added to the mothers set if necessary.
   */
  async updateBirth(
    { offspringId, birthDate, fatherId, motherId, countBorn, sex, notes }:
      { offspringId: ID; birthDate?: Date; fatherId?: ID; motherId?: ID; countBorn?: number; sex?: Sex; notes?: string },
  ): Promise<{ offspring?: Offspring; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }

    const updateFields: Partial<Offspring> = {};
    if (birthDate !== undefined) updateFields.birthDate = new Date(birthDate);
    if (fatherId !== undefined) updateFields.fatherId = fatherId;
    if (countBorn !== undefined) updateFields.countBorn = countBorn;
    if (sex !== undefined) updateFields.sex = sex;
    if (notes !== undefined) updateFields.notes = notes;

    // Handle mother ID change
    if (motherId !== undefined && motherId !== existingOffspring.motherId) {
      // Ensure the new mother exists or add her
      const existingNewMother = await this.mothers.findOne({ _id: motherId });
      if (!existingNewMother) {
        await this.addMother({ motherId }); // Ignoring error result, assuming success or critical failure
      }
      updateFields.motherId = motherId;
    }

    // --- FIX START ---
    // The `findOneAndUpdate` method with `returnDocument: "after"` in this Deno setup
    // returns `WithId<Offspring> | null` directly, which is assignable to `Offspring | null`
    const updatedOffspring: Offspring | null = await this.offspring.findOneAndUpdate(
      { _id: offspringId },
      { $set: updateFields },
      { returnDocument: "after", upsert: false }, // Added upsert: false for clarity
    );

    // Check if the document was found and updated (updatedOffspring is null if no document matched)
    if (!updatedOffspring) {
      return { error: `Failed to update offspring with ID ${offspringId}. Document not found or could not be updated.` };
    }
    return { offspring: updatedOffspring };
    // --- FIX END ---
  }

  /**
   * **action** `recordWeaning (offspring: ID): offspring: ID`
   *
   * **requires** offspring is in the set of offspring and is alive
   * **effects** Sets `survivedTillWeaning` to be true for the specified offspring
   */
  async recordWeaning({ offspringId }: { offspringId: ID }): Promise<{ offspringId?: ID; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }
    if (!existingOffspring.isAlive) {
      return { error: `Offspring with ID ${offspringId} is not alive and cannot be weaned.` };
    }
    if (existingOffspring.survivedTillWeaning) {
      return { error: `Offspring with ID ${offspringId} is already marked as weaned.` };
    }

    const result = await this.offspring.updateOne(
      { _id: offspringId },
      { $set: { survivedTillWeaning: true } },
    );

    if (result.modifiedCount === 0) {
      return { error: `Failed to record weaning for offspring with ID ${offspringId}.` };
    }
    return { offspringId };
  }

  /**
   * **action** `recordDeath (offspring: ID): (offspring: ID)`
   *
   * **requires** offspring is in the set of offspring and is currently living
   * **effects** Sets the `isAlive` flag of this offspring to false
   */
  async recordDeath({ offspringId }: { offspringId: ID }): Promise<{ offspringId?: ID; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }
    if (!existingOffspring.isAlive) {
      return { error: `Offspring with ID ${offspringId} is already marked as deceased.` };
    }

    const result = await this.offspring.updateOne(
      { _id: offspringId },
      { $set: { isAlive: false } },
    );

    if (result.modifiedCount === 0) {
      return { error: `Failed to record death for offspring with ID ${offspringId}.` };
    }
    return { offspringId };
  }

  /**
   * **action** `viewOffspring (mother: ID): (offspring: Set<offspring>)`
   *
   * **requires** animal exists (as a mother)
   * **effects** return the full details of all offspring associated with the given mother ID.
   */
  async viewOffspring({ motherId }: { motherId: ID }): Promise<{ offspring?: Offspring[]; error?: string }> {
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (!existingMother) {
      return { error: `Mother with ID ${motherId} not found.` };
    }

    const offspringList = await this.offspring.find({ motherId }).toArray();
    return { offspring: offspringList };
  }

  /**
   * **action** `generateReport (target: Set<ID>, startDateRange: Date, endDateRange: Date, name: String?): (report: GeneratedReport)`
   *
   * **requires** All target animals are in the set of mothers
   * **effects** produce a report on the reproductive performance of the given animals within the specified date range and store it.
   */
  async generateReport(
    { target, startDateRange, endDateRange, name }:
      { target: ID[]; startDateRange: Date; endDateRange: Date; name?: string },
  ): Promise<{ report?: GeneratedReport; error?: string }> {
    // Validate target mothers
    const mothersExistCount = await this.mothers.countDocuments({ _id: { $in: target } });
    if (mothersExistCount !== target.length) {
      return { error: "One or more target IDs are not registered mothers." };
    }

    // Generate a default name if none is provided
    const reportName = name || `Reproduction Report - ${new Date().toISOString().split('T')[0]}`;

    // Check for existing report with the same name to ensure uniqueness
    const existingReport = await this.generatedReports.findOne({ reportName });
    if (existingReport) {
      return { error: `Report with name '${reportName}' already exists.` };
    }

    const startDate = new Date(startDateRange);
    const endDate = new Date(endDateRange);

    // --- Report Data Aggregation (Simplified Example) ---
    const relevantOffspring = await this.offspring.find({
      motherId: { $in: target },
      birthDate: { $gte: startDate, $lte: endDate },
    }).toArray();

    const totalOffspringBorn = relevantOffspring.reduce((sum, o) => sum + o.countBorn, 0);
    const uniqueBirthEvents = relevantOffspring.length; // Each entry is a birth event
    const totalWeanedOffspring = relevantOffspring.filter((o) => o.survivedTillWeaning).length;
    const totalDeceasedOffspring = relevantOffspring.filter((o) => !o.isAlive).length;

    const averageLitterSize = uniqueBirthEvents > 0
      ? totalOffspringBorn / uniqueBirthEvents
      : 0;
    const survivabilityRateToWeaning = totalOffspringBorn > 0
      ? (totalWeanedOffspring / totalOffspringBorn) * 100
      : 0;

    const reportResults = {
      totalOffspringBorn: totalOffspringBorn,
      uniqueBirthEvents: uniqueBirthEvents,
      totalWeanedOffspring: totalWeanedOffspring,
      totalDeceasedOffspring: totalDeceasedOffspring,
      averageLitterSize: parseFloat(averageLitterSize.toFixed(2)),
      survivabilityRateToWeaning: `${survivabilityRateToWeaning.toFixed(2)}%`,
      motherCount: target.length,
      reportPeriod: `${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`,
    };

    const newReport: GeneratedReport = {
      _id: freshID(),
      reportName,
      dateGenerated: new Date(),
      target,
      results: reportResults,
    };

    await this.generatedReports.insertOne(newReport);
    return { report: newReport };
  }

  /**
   * **action** `renameReport (oldName: String, newName: String): (report: GeneratedReport)`
   *
   * **requires** oldName of report exists
   * **effects** renames the specified report
   */
  async renameReport(
    { oldName, newName }: { oldName: string; newName: string },
  ): Promise<{ report?: GeneratedReport; error?: string }> {
    const existingReport = await this.generatedReports.findOne({ reportName: oldName });
    if (!existingReport) {
      return { error: `Report with name '${oldName}' not found.` };
    }

    const nameConflict = await this.generatedReports.findOne({ reportName: newName });
    if (nameConflict) {
      return { error: `Report with new name '${newName}' already exists.` };
    }

    // --- FIX START ---
    // The `findOneAndUpdate` method with `returnDocument: "after"` in this Deno setup
    // returns `WithId<GeneratedReport> | null` directly, which is assignable to `GeneratedReport | null`
    const updatedReport: GeneratedReport | null = await this.generatedReports.findOneAndUpdate(
      { _id: existingReport._id },
      { $set: { reportName: newName } },
      { returnDocument: "after", upsert: false }, // Added upsert: false for clarity
    );

    // Check if the document was found and updated (updatedReport is null if no document matched)
    if (!updatedReport) {
      return { error: `Failed to rename report '${oldName}'. Document not found or could not be updated.` };
    }
    return { report: updatedReport };
    // --- FIX END ---
  }

  /**
   * **action** `viewReport (report: GeneratedReport): (results: GeneratedReport)`
   *
   * **requires** report with the given name exists
   * **effects** returns the full details (summary and results) of the specified report
   */
  async viewReport({ reportName }: { reportName: string }): Promise<{ report?: GeneratedReport; error?: string }> {
    const report = await this.generatedReports.findOne({ reportName });
    if (!report) {
      return { error: `Report with name '${reportName}' not found.` };
    }
    return { report };
  }

  /**
   * **action** `listReports (): (reports: Set<GeneratedReport>)`
   *
   * **effects** returns all generated reports in the system
   */
  async listReports(): Promise<{ reports: GeneratedReport[] }> {
    const reports = await this.generatedReports.find({}).toArray();
    return { reports };
  }

  /**
   * **action** `deleteReport (report: String)`
   *
   * **requires** report with the given name exists
   * **effects** removes the specified report from the system
   */
  async deleteReport({ reportName }: { reportName: string }): Promise<Empty | { error: string }> {
    const result = await this.generatedReports.deleteOne({ reportName });
    if (result.deletedCount === 0) {
      return { error: `Report with name '${reportName}' not found.` };
    }
    return {};
  }

  /**
   * **action** `aiSummary (report: Report): (summary: String)`
   *
   * **requires** report exists
   * **effects** The AI generates a summary of the report, highlighting key takeaways and trends shown in the report.
   *            (Placeholder for actual AI integration)
   */
  async aiSummary({ reportName }: { reportName: string }): Promise<{ summary?: string; error?: string }> {
    const report = await this.generatedReports.findOne({ reportName });
    if (!report) {
      return { error: `Report with name '${reportName}' not found.` };
    }

    // Placeholder for actual AI summary generation logic.
    // In a real scenario, this would call an external AI service with report.results.
    const summary = `AI Summary for Report '${report.reportName}' (Generated: ${report.dateGenerated.toLocaleDateString()}):\n` +
      `This report analyzes the reproductive performance of ${report.results.motherCount} mothers ` +
      `during the period from ${report.results.reportPeriod}.\n` +
      `Key metrics: A total of ${report.results.totalOffspringBorn} offspring were born across ` +
      `${report.results.uniqueBirthEvents} distinct birth events, with an average litter size of ` +
      `${report.results.averageLitterSize}. The survivability rate to weaning stands at ` +
      `${report.results.survivabilityRateToWeaning}. \n` +
      `There were ${report.results.totalDeceasedOffspring} recorded deceased offspring. ` +
      `This indicates a need to investigate factors contributing to mortality and opportunities ` +
      `to enhance the weaning success rate to improve overall reproductive efficiency.`;

    return { summary };
  }
}
```
