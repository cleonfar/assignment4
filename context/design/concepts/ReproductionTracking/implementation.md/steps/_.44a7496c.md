---
timestamp: 'Thu Oct 16 2025 00:28:40 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_002840.1251a93e.md]]'
content_id: 44a7496c563921fea42b7f2558c3e6043773cbc24db51cf0e9185494699939fc
---

# Updated TypeScript Code

Now, let's apply these changes to the `ReproductionTrackingConcept.ts` file.

```typescript
// file: src/ReproductionTracking/ReproductionTrackingConcept.ts
import { Collection, Db } from "npm:mongodb";
import { GoogleGenerativeAI } from "npm:@google/generative-ai"; // Added this import
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";

// Declare collection prefix, use concept name
const PREFIX = "ReproductionTracking" + ".";

/**
 * Enum for the sex of an offspring.
 */
export enum Sex { // Exported for external use in syncs or tests
  Male = "male",
  Female = "female",
  Neuter = "neutered",
}

/**
 * Represents a mother animal in the system.
 *
 * **state**: a set of `mothers` with
 *   - an `ID` of type `ID`
 *   - an optional `notes` of type `String`
 */
interface Mother {
  _id: ID;
  notes?: string;
}

/**
 * Represents an offspring animal (an individual).
 *
 * **state**: a set of `offspring` with
 *   - an `ID` of type `ID`
 *   - an optional `fatherId` of type `ID`
 *   - a `birthDate` of type `Date`
 *   - a `sex` of type `Enum [male, female, neutered]`
 *   - an optional `notes` of type `String`
 *   - a `isAlive` of type `Bool`
 *   - a `survivedTillWeaning` of type `Bool`
 *
 * NOTE: `countBorn` has been removed as `Offspring` now consistently represents an individual animal.
 */
interface Offspring {
  _id: ID;
  motherId: ID; // Link to the mother animal
  fatherId?: ID;
  birthDate: Date;
  sex: Sex;
  notes?: string;
  isAlive: boolean; // Renamed from 'status' for clarity on state
  survivedTillWeaning: boolean;
}

/**
 * Represents a generated report.
 *
 * **state**: a set of `GeneratedReports` with
 *   - a `report name` of type `String`
 *   - a `dateGenerated` of type `Date`
 *   - a `target` of type `Set<ID>`
 *   - a set of `results` of type `(key-value pairs or tabular data)`
 */
interface GeneratedReport {
  _id: ID;
  reportName: string;
  dateGenerated: Date;
  target: ID[]; // Set of mother IDs this report covers
  results: Record<string, any>; // Flexible structure for report data
}

/**
 * **concept** ReproductionTracking
 *
 * **purpose** track reproductive outcomes and offspring survivability for breeding animals
 *
 * **principle**
 *   a user records birth events for mother animals, optionally linking fathers and offspring;
 *   later records weaning outcomes for those offspring when the data becomes available;
 *   uses this data to generate reports to evaluate reproductive performance and inform breeding decisions;
 *   can choose to generate an AI summary of generated reports to aide in understanding and decision making;
 */
export default class ReproductionTrackingConcept {
  private mothers: Collection<Mother>;
  private offspring: Collection<Offspring>;
  private generatedReports: Collection<GeneratedReport>;

  constructor(private readonly db: Db) {
    this.mothers = this.db.collection(PREFIX + "mothers");
    this.offspring = this.db.collection(PREFIX + "offspring");
    this.generatedReports = this.db.collection(PREFIX + "generatedReports");
  }

  /**
   * **action** `addMother (motherId: ID): (motherId: ID)`
   *
   * **requires** mother is not already in the set of mothers
   * **effects** mother is added to the set of mothers
   */
  async addMother({ motherId }: { motherId: ID }): Promise<{ motherId?: ID; error?: string }> {
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (existingMother) {
      return { error: `Mother with ID ${motherId} already exists.` };
    }

    const newMother: Mother = { _id: motherId };
    await this.mothers.insertOne(newMother);
    return { motherId };
  }

  /**
   * **action** `removeMother (motherId: ID): (motherId: ID)`
   *
   * **requires** a mother with this ID is in the set of mothers
   * **effects** removes this mother from the set of mothers. Offspring previously linked to this mother
   *            will remain in the system but their `motherId` will point to a non-existent record.
   */
  async removeMother({ motherId }: { motherId: ID }): Promise<{ motherId?: ID; error?: string }> {
    const result = await this.mothers.deleteOne({ _id: motherId });
    if (result.deletedCount === 0) {
      return { error: `Mother with ID ${motherId} not found.` };
    }
    return { motherId };
  }

  /**
   * **action** `recordBirth (motherId: ID, fatherId: ID?, birthDate: Date, offspringId: ID, sex: Enum [male, female, neutered], notes: String?): (offspring: Offspring)`
   *
   * **effects** adds the recorded offspring to the set of offspring. Also adds the mother to the set of mothers if she isn't there already
   */
  async recordBirth(
    { motherId, fatherId, birthDate, offspringId, sex, notes }:
      { motherId: ID; fatherId?: ID; birthDate: Date; offspringId: ID; sex: Sex; notes?: string },
  ): Promise<{ offspring?: Offspring; error?: string }> {
    // Add mother if she doesn't exist already
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (!existingMother) {
      // Intentionally ignoring the result/error of addMother here, assuming it will either succeed
      // or a critical database error will be thrown naturally.
      await this.addMother({ motherId });
    }

    // Check if offspring ID already exists to prevent duplicates
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (existingOffspring) {
      return { error: `Offspring with ID ${offspringId} already exists.` };
    }

    const newOffspring: Offspring = {
      _id: offspringId, // Use the provided offspringId as the primary key
      motherId,
      fatherId,
      birthDate: new Date(birthDate), // Ensure `birthDate` is a Date object
      sex,
      notes,
      isAlive: true, // Default to alive at birth
      survivedTillWeaning: false, // Default to not yet weaned
    };

    await this.offspring.insertOne(newOffspring);
    return { offspring: newOffspring };
  }

  /**
   * **action** `updateBirth (offspringId: ID, birthDate: Date?, fatherId: ID?, motherId: ID?, sex: Enum?, notes: String?): (offspring: Offspring)`
   *
   * **requires** There is an offspring with the given ID
   * **effects** Updates any given information about the offspring's birth. If the mother is changed,
   *            the offspring's `motherId` is updated, and the new mother is added to the mothers set if necessary.
   */
  async updateBirth(
    { offspringId, birthDate, fatherId, motherId, sex, notes }:
      { offspringId: ID; birthDate?: Date; fatherId?: ID; motherId?: ID; sex?: Sex; notes?: string },
  ): Promise<{ offspring?: Offspring; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }

    const updateFields: Partial<Offspring> = {};
    if (birthDate !== undefined) updateFields.birthDate = new Date(birthDate);
    if (fatherId !== undefined) updateFields.fatherId = fatherId;
    if (sex !== undefined) updateFields.sex = sex;
    if (notes !== undefined) updateFields.notes = notes;

    // Handle mother ID change
    if (motherId !== undefined && motherId !== existingOffspring.motherId) {
      // Ensure the new mother exists or add her
      const existingNewMother = await this.mothers.findOne({ _id: motherId });
      if (!existingNewMother) {
        await this.addMother({ motherId }); // Ignoring error result, assuming success or critical failure
      }
      updateFields.motherId = motherId;
    }

    const updatedOffspring: Offspring | null = await this.offspring.findOneAndUpdate(
      { _id: offspringId },
      { $set: updateFields },
      { returnDocument: "after", upsert: false },
    );

    if (!updatedOffspring) {
      return { error: `Failed to update offspring with ID ${offspringId}. Document not found or could not be updated.` };
    }
    return { offspring: updatedOffspring };
  }

  /**
   * **action** `recordWeaning (offspringId: ID): offspringId: ID`
   *
   * **requires** offspring is in the set of offspring and is alive
   * **effects** Sets `survivedTillWeaning` to be true for the specified offspring
   */
  async recordWeaning({ offspringId }: { offspringId: ID }): Promise<{ offspringId?: ID; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }
    if (!existingOffspring.isAlive) {
      return { error: `Offspring with ID ${offspringId} is not alive and cannot be weaned.` };
    }
    if (existingOffspring.survivedTillWeaning) {
      return { error: `Offspring with ID ${offspringId} is already marked as weaned.` };
    }

    const result = await this.offspring.updateOne(
      { _id: offspringId },
      { $set: { survivedTillWeaning: true } },
    );

    if (result.modifiedCount === 0) {
      return { error: `Failed to record weaning for offspring with ID ${offspringId}.` };
    }
    return { offspringId };
  }

  /**
   * **action** `recordDeath (offspringId: ID): (offspringId: ID)`
   *
   * **requires** offspring is in the set of offspring and is currently living
   * **effects** Sets the `isAlive` flag of this offspring to false
   */
  async recordDeath({ offspringId }: { offspringId: ID }): Promise<{ offspringId?: ID; error?: string }> {
    const existingOffspring = await this.offspring.findOne({ _id: offspringId });
    if (!existingOffspring) {
      return { error: `Offspring with ID ${offspringId} not found.` };
    }
    if (!existingOffspring.isAlive) {
      return { error: `Offspring with ID ${offspringId} is already marked as deceased.` };
    }

    const result = await this.offspring.updateOne(
      { _id: offspringId },
      { $set: { isAlive: false } },
    );

    if (result.modifiedCount === 0) {
      return { error: `Failed to record death for offspring with ID ${offspringId}.` };
    }
    return { offspringId };
  }

  /**
   * **action** `viewOffspring (motherId: ID): (offspring: Set<offspring>)`
   *
   * **requires** animal exists (as a mother)
   * **effects** return the full details of all offspring associated with the given mother ID.
   */
  async viewOffspring({ motherId }: { motherId: ID }): Promise<{ offspring?: Offspring[]; error?: string }> {
    const existingMother = await this.mothers.findOne({ _id: motherId });
    if (!existingMother) {
      return { error: `Mother with ID ${motherId} not found.` };
    }

    const offspringList = await this.offspring.find({ motherId }).toArray();
    return { offspring: offspringList };
  }

  /**
   * **action** `generateReport (target: Set<ID>, startDateRange: Date, endDateRange: Date, name: String?): (report: GeneratedReport)`
   *
   * **requires** All target animals are in the set of mothers
   * **effects** produce a report on the reproductive performance of the given animals within the specified date range and store it.
   */
  async generateReport(
    { target, startDateRange, endDateRange, name }:
      { target: ID[]; startDateRange: Date; endDateRange: Date; name?: string },
  ): Promise<{ report?: GeneratedReport; error?: string }> {
    // Validate target mothers
    const mothersExistCount = await this.mothers.countDocuments({ _id: { $in: target } });
    if (mothersExistCount !== target.length) {
      return { error: "One or more target IDs are not registered mothers." };
    }

    // Generate a default name if none is provided
    const reportName = name || `Reproduction Report - ${new Date().toISOString().split('T')[0]}`;

    // Check for existing report with the same name to ensure uniqueness
    const existingReport = await this.generatedReports.findOne({ reportName });
    if (existingReport) {
      return { error: `Report with name '${reportName}' already exists.` };
    }

    const startDate = new Date(startDateRange);
    const endDate = new Date(endDateRange);

    // --- Report Data Aggregation ---
    // Relevant offspring are now simply individual offspring born within the date range by the target mothers.
    const relevantOffspring = await this.offspring.find({
      motherId: { $in: target },
      birthDate: { $gte: startDate, $lte: endDate },
    }).toArray();

    const totalOffspringBorn = relevantOffspring.length; // Count of individual offspring records
    const totalWeanedOffspring = relevantOffspring.filter((o) => o.survivedTillWeaning).length;
    const totalDeceasedOffspring = relevantOffspring.filter((o) => !o.isAlive).length;

    // Survivability rate adjusted to reflect total individual offspring born
    const survivabilityRateToWeaning = totalOffspringBorn > 0
      ? (totalWeanedOffspring / totalOffspringBorn) * 100
      : 0;

    const reportResults = {
      totalOffspringBorn: totalOffspringBorn,
      totalWeanedOffspring: totalWeanedOffspring,
      totalDeceasedOffspring: totalDeceasedOffspring,
      survivabilityRateToWeaning: `${survivabilityRateToWeaning.toFixed(2)}%`,
      motherCount: target.length,
      reportPeriod: `${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`,
    };

    const newReport: GeneratedReport = {
      _id: freshID(),
      reportName,
      dateGenerated: new Date(),
      target,
      results: reportResults,
    };

    await this.generatedReports.insertOne(newReport);
    return { report: newReport };
  }

  /**
   * **action** `renameReport (oldName: String, newName: String): (report: GeneratedReport)`
   *
   * **requires** oldName of report exists
   * **effects** renames the specified report
   */
  async renameReport(
    { oldName, newName }: { oldName: string; newName: string },
  ): Promise<{ report?: GeneratedReport; error?: string }> {
    const existingReport = await this.generatedReports.findOne({ reportName: oldName });
    if (!existingReport) {
      return { error: `Report with name '${oldName}' not found.` };
    }

    const nameConflict = await this.generatedReports.findOne({ reportName: newName });
    if (nameConflict) {
      return { error: `Report with new name '${newName}' already exists.` };
    }

    const updatedReport: GeneratedReport | null = await this.generatedReports.findOneAndUpdate(
      { _id: existingReport._id },
      { $set: { reportName: newName } },
      { returnDocument: "after", upsert: false },
    );

    if (!updatedReport) {
      return { error: `Failed to rename report '${oldName}'. Document not found or could not be updated.` };
    }
    return { report: updatedReport };
  }

  /**
   * **action** `viewReport (reportName: String): (report: GeneratedReport)`
   *
   * **requires** report with the given name exists
   * **effects** returns the full details (summary and results) of the specified report
   */
  async viewReport({ reportName }: { reportName: string }): Promise<{ report?: GeneratedReport; error?: string }> {
    const report = await this.generatedReports.findOne({ reportName });
    if (!report) {
      return { error: `Report with name '${reportName}' not found.` };
    }
    return { report };
  }

  /**
   * **action** `listReports (): (reports: Set<GeneratedReport>)`
   *
   * **effects** returns all generated reports in the system
   */
  async listReports(): Promise<{ reports: GeneratedReport[] }> {
    const reports = await this.generatedReports.find({}).toArray();
    return { reports };
  }

  /**
   * **action** `deleteReport (reportName: String)`
   *
   * **requires** report with the given name exists
   * **effects** removes the specified report from the system
   */
  async deleteReport({ reportName }: { reportName: string }): Promise<Empty | { error: string }> {
    const result = await this.generatedReports.deleteOne({ reportName });
    if (result.deletedCount === 0) {
      return { error: `Report with name '${reportName}' not found.` };
    }
    return {};
  }

  /**
   * **action** `aiSummary (reportName: String): (summary: String)`
   *
   * **requires** report exists
   * **effects** The AI generates a summary of the report, highlighting key takeaways and trends shown in the report.
   */
  async aiSummary({ reportName }: { reportName: string }): Promise<{ summary?: string; error?: string }> {
    const report = await this.generatedReports.findOne({ reportName });
    if (!report) {
      return { error: `Report with name '${reportName}' not found.` };
    }

    const apiKey = Deno.env.get("GEMINI_API_KEY");
    if (!apiKey) {
      return { error: "GEMINI_API_KEY environment variable is not set." };
    }

    try {
      const genAI = new GoogleGenerativeAI(apiKey);
      const model = genAI.getGenerativeModel({ model: "gemini-pro" });

      // Updated prompt to reflect the new report structure
      const prompt = `You are an expert animal husbandry analyst.
Please provide a concise and insightful summary of the following animal reproduction report.
Highlight key takeaways, trends, and actionable insights that can inform breeding decisions.
Focus on reproductive performance and survivability of individual offspring.

Reproduction Report Details:
Report Name: "${report.reportName}"
Date Generated: ${report.dateGenerated.toLocaleDateString()}
Target Mothers Count: ${report.results.motherCount}
Report Period: ${report.results.reportPeriod}

Metrics:
- Total Individual Offspring Born: ${report.results.totalOffspringBorn}
- Total Individual Offspring Weaned: ${report.results.totalWeanedOffspring}
- Survivability Rate to Weaning: ${report.results.survivabilityRateToWeaning}
- Total Individual Offspring Deceased (Post-Birth, Pre-Weaning): ${report.results.totalDeceasedOffspring}

Based on this data, provide a professional summary:`;

      const result = await model.generateContent(prompt);
      const response = await result.response;
      const summary = response.text();

      return { summary: summary.trim() };
    } catch (e) {
      console.error("Error generating AI summary:", e);
      return { error: `Failed to generate AI summary: ${e.message || "An unknown error occurred."}` };
    }
  }
}
```
