---
timestamp: 'Thu Oct 16 2025 14:26:19 GMT-0400 (Eastern Daylight Time)'
parent: '[[..\20251016_142619.b16070c9.md]]'
content_id: 35a0947fbef46f73f5e51fd8677cec7a51665b9f2841b52a66ae0267352e253a
---

# Test implementation

```typescript
// file: src/ReproductionTracking/ReproductionTrackingConcept.test.ts
import { Collection, Db, MongoClient, ObjectId } from "npm:mongodb"; // Import ObjectId
import { assertEquals, assertExists, assertNotEquals, assertArrayIncludes, assert } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import ReproductionTrackingConcept, { Sex } from "./ReproductionTrackingConcept.ts";
import { ID } from "@utils/types.ts";
// Assuming freshID is imported for generating generic test IDs if needed, though createBrandedId is used for fixed ones.
import { freshID } from "@utils/database.ts"; 

const PREFIX = "ReproductionTracking" + ".";

// Helper function to create a branded ID from a string literal for testing
// This is necessary because `ID` is a branded type, and direct string literals don't satisfy it.
function createBrandedId(value: string): ID {
  return value as ID;
}

// Helper to convert external branded ID (string) to internal ObjectId for DB queries in tests.
function brandedIdToObjectId(id: ID): ObjectId {
  return new ObjectId(id);
}

Deno.test("ReproductionTrackingConcept", async (t) => {
  let db: Db;
  let client: MongoClient;
  let concept: ReproductionTrackingConcept;

  Deno.test.beforeEach(async () => {
    [db, client] = await testDb();
    concept = new ReproductionTrackingConcept(db);
  });

  Deno.test.afterEach(async () => {
    await client.close();
  });

  await t.step("addMother action", async (t) => {
    const motherId: ID = createBrandedId("mother1"); // Use helper

    await t.step("should add a new mother", async () => {
      const result = await concept.addMother({ motherId });
      assertEquals(result.motherId, motherId);

      // Query DB directly: _id is ObjectId internally
      const addedMother = await db.collection(PREFIX + "mothers").findOne({ _id: brandedIdToObjectId(motherId) });
      assertExists(addedMother);
      assertEquals(addedMother._id.toHexString(), motherId); // Convert ObjectId to string for comparison
    });

    await t.step("should return an error if mother already exists", async () => {
      const motherId2: ID = createBrandedId("mother2");
      await concept.addMother({ motherId: motherId2 });
      const result = await concept.addMother({ motherId: motherId2 });
      assertExists(result.error);
      assertEquals(result.error, `Mother with ID ${motherId2} already exists.`);
    });
  });

  await t.step("removeMother action", async (t) => {
    const motherId: ID = createBrandedId("motherToRemove");

    await t.step("should remove an existing mother", async () => {
      await concept.addMother({ motherId });
      const result = await concept.removeMother({ motherId });
      assertEquals(result.motherId, motherId);

      const removedMother = await db.collection(PREFIX + "mothers").findOne({ _id: brandedIdToObjectId(motherId) });
      assertEquals(removedMother, null);
    });

    await t.step("should return an error if mother not found", async () => {
      const result = await concept.removeMother({ motherId: createBrandedId("nonExistentMother") });
      assertExists(result.error);
      assertEquals(result.error, "Mother with ID nonExistentMother not found.");
    });
  });

  await t.step("recordLitter action", async (t) => {
    const motherId: ID = createBrandedId("mother3");
    const fatherId: ID = createBrandedId("father1");
    const birthDate = new Date("2023-01-01T00:00:00.000Z");
    const reportedLitterSize = 5;

    await t.step("should create a new litter for an existing mother", async () => {
      await concept.addMother({ motherId });
      const result = await concept.recordLitter({ motherId, fatherId, birthDate, reportedLitterSize });

      assertExists(result.litter);
      // Return type is LitterDTO, so IDs are strings
      assert(typeof result.litter._id === 'string');
      assertEquals(result.litter.motherId, motherId);
      assertEquals(result.litter.fatherId, fatherId);
      assertEquals(result.litter.birthDate.toISOString(), birthDate.toISOString());
      assertEquals(result.litter.reportedLitterSize, reportedLitterSize);

      // Query DB directly: _id is ObjectId internally
      const addedLitter = await db.collection(PREFIX + "litters").findOne({ _id: brandedIdToObjectId(result.litter._id) });
      assertExists(addedLitter);
      assertEquals(addedLitter.motherId.toHexString(), motherId); // Compare ObjectId to string
    });

    await t.step("should add mother if she doesn't exist and create litter", async () => {
      const newMotherId: ID = createBrandedId("newMotherForLitter");
      const result = await concept.recordLitter({
        motherId: newMotherId,
        birthDate,
        reportedLitterSize: 3,
      });

      assertExists(result.litter);
      assertEquals(result.litter.motherId, newMotherId);

      // Verify mother added
      const addedMother = await db.collection(PREFIX + "mothers").findOne({ _id: brandedIdToObjectId(newMotherId) });
      assertExists(addedMother);
    });

    await t.step("should return an error for duplicate litter (same mother, father, birthDate)", async () => {
      const motherId4: ID = createBrandedId("mother4");
      const fatherDuplicate: ID = createBrandedId("fatherDuplicate");
      await concept.addMother({ motherId: motherId4 });
      await concept.recordLitter({
        motherId: motherId4,
        fatherId: fatherDuplicate,
        birthDate,
        reportedLitterSize: 4,
      });
      const result = await concept.recordLitter({
        motherId: motherId4,
        fatherId: fatherDuplicate,
        birthDate,
        reportedLitterSize: 5, // Different size, but still a duplicate based on unique key
      });

      assertExists(result.error);
      assertEquals(result.error, `A litter for mother ${motherId4} with this father and birth date already exists.`);
    });
  });

  await t.step("updateLitter action", async (t) => {
    const motherId: ID = createBrandedId("mother5");
    const fatherId: ID = createBrandedId("father2");
    const birthDate = new Date("2023-02-01T00:00:00.000Z");
    const reportedLitterSize = 6;
    let litterId: ID;

    await t.step("setup: record a litter to update", async () => {
      await concept.addMother({ motherId });
      const recordResult = await concept.recordLitter({
        motherId,
        fatherId,
        birthDate,
        reportedLitterSize,
        notes: "initial notes",
      });
      assertExists(recordResult.litter);
      litterId = recordResult.litter._id; // LitterDTO._id is branded string
    });

    await t.step("should update notes and reportedLitterSize", async () => {
      const newNotes = "updated notes";
      const newReportedSize = 7;
      const result = await concept.updateLitter({
        litterId,
        notes: newNotes,
        reportedLitterSize: newReportedSize,
      });

      assertExists(result.litter);
      assertEquals(result.litter._id, litterId);
      assertEquals(result.litter.notes, newNotes);
      assertEquals(result.litter.reportedLitterSize, newReportedSize);

      const updatedLitter = await db.collection(PREFIX + "litters").findOne({ _id: brandedIdToObjectId(litterId) });
      assertExists(updatedLitter);
      assertEquals(updatedLitter.notes, newNotes);
      assertEquals(updatedLitter.reportedLitterSize, newReportedSize);
    });

    await t.step("should update motherId to an existing mother", async () => {
      const newMotherId: ID = createBrandedId("mother6");
      await concept.addMother({ motherId: newMotherId });
      const result = await concept.updateLitter({ litterId, motherId: newMotherId });

      assertExists(result.litter);
      assertEquals(result.litter.motherId, newMotherId); // LitterDTO.motherId is branded string

      const updatedLitter = await db.collection(PREFIX + "litters").findOne({ _id: brandedIdToObjectId(litterId) });
      assertExists(updatedLitter);
      assertEquals(updatedLitter.motherId.toHexString(), newMotherId); // Compare ObjectId to branded string
    });

    await t.step("should update motherId to a new mother (and add her)", async () => {
      const brandNewMotherId: ID = createBrandedId("mother7");
      const result = await concept.updateLitter({ litterId, motherId: brandNewMotherId });

      assertExists(result.litter);
      assertEquals(result.litter.motherId, brandNewMotherId);

      const addedMother = await db.collection(PREFIX + "mothers").findOne({ _id: brandedIdToObjectId(brandNewMotherId) });
      assertExists(addedMother);
    });

    await t.step("should return an error if litter not found", async () => {
      const result = await concept.updateLitter({ litterId: createBrandedId("nonExistentLitter"), notes: "no" });
      assertExists(result.error);
      assertEquals(result.error, "Litter with ID nonExistentLitter not found.");
    });
  });

  await t.step("recordOffspring action", async (t) => {
    let litterId: ID;
    const motherId: ID = createBrandedId("mother8");

    await t.step("setup: record a litter", async () => {
      await concept.addMother({ motherId });
      const recordResult = await concept.recordLitter({
        motherId,
        birthDate: new Date("2023-03-01"),
        reportedLitterSize: 3,
      });
      assertExists(recordResult.litter);
      litterId = recordResult.litter._id; // LitterDTO._id is branded string
    });

    await t.step("should create a new offspring record", async () => {
      const offspringId: ID = createBrandedId("offspring1");
      const result = await concept.recordOffspring({ litterId, offspringId, sex: Sex.Female });

      assertExists(result.offspring);
      assertEquals(result.offspring._id, offspringId);
      assertEquals(result.offspring.litterId, litterId);
      assertEquals(result.offspring.sex, Sex.Female);
      assertEquals(result.offspring.isAlive, true);
      assertEquals(result.offspring.survivedTillWeaning, false);

      const addedOffspring = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(offspringId) });
      assertExists(addedOffspring);
    });

    await t.step("should return an error if litterId does not exist", async () => {
      const result = await concept.recordOffspring({
        litterId: createBrandedId("nonExistentLitterId"),
        offspringId: createBrandedId("offspring2"),
        sex: Sex.Male,
      });
      assertExists(result.error);
      assertEquals(result.error, "Litter with ID nonExistentLitterId not found.");
    });

    await t.step("should return an error if offspringId already exists", async () => {
      const offspringId: ID = createBrandedId("offspringExisting");
      await concept.recordOffspring({ litterId, offspringId, sex: Sex.Male });
      const result = await concept.recordOffspring({ litterId, offspringId, sex: Sex.Female });
      assertExists(result.error);
      assertEquals(result.error, `Offspring with ID ${offspringId} already exists.`);
    });
  });

  await t.step("updateOffspring action", async (t) => {
    let litterId1: ID, litterId2: ID;
    let offspringId: ID;

    await t.step("setup: record mothers, litters, and offspring", async () => {
      const mother9 = createBrandedId("mother9");
      const mother10 = createBrandedId("mother10");
      await concept.addMother({ motherId: mother9 });
      await concept.addMother({ motherId: mother10 });

      const litterResult1 = await concept.recordLitter({
        motherId: mother9,
        birthDate: new Date("2023-04-01"),
        reportedLitterSize: 2,
      });
      assertExists(litterResult1.litter);
      litterId1 = litterResult1.litter._id;

      const litterResult2 = await concept.recordLitter({
        motherId: mother10,
        birthDate: new Date("2023-04-05"),
        reportedLitterSize: 3,
      });
      assertExists(litterResult2.litter);
      litterId2 = litterResult2.litter._id;

      const offspringResult = await concept.recordOffspring({
        litterId: litterId1,
        offspringId: createBrandedId("offspringToUpdate"),
        sex: Sex.Male,
        notes: "initial notes",
      });
      assertExists(offspringResult.offspring);
      offspringId = offspringResult.offspring._id;
    });

    await t.step("should update sex and notes", async () => {
      const newNotes = "updated offspring notes";
      const result = await concept.updateOffspring({ offspringId, sex: Sex.Female, notes: newNotes });

      assertExists(result.offspring);
      assertEquals(result.offspring._id, offspringId);
      assertEquals(result.offspring.sex, Sex.Female);
      assertEquals(result.offspring.notes, newNotes);

      const updatedOffspring = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(offspringId) });
      assertExists(updatedOffspring);
      assertEquals(updatedOffspring.sex, Sex.Female);
      assertEquals(updatedOffspring.notes, newNotes);
    });

    await t.step("should update litterId to an existing litter", async () => {
      const result = await concept.updateOffspring({ offspringId, litterId: litterId2 });

      assertExists(result.offspring);
      assertEquals(result.offspring.litterId, litterId2);

      const updatedOffspring = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(offspringId) });
      assertExists(updatedOffspring);
      assertEquals(updatedOffspring.litterId.toHexString(), litterId2);
    });

    await t.step("should return an error if new litterId does not exist", async () => {
      const result = await concept.updateOffspring({ offspringId, litterId: createBrandedId("nonExistentNewLitter") });
      assertExists(result.error);
      assertEquals(result.error, "New litter with ID nonExistentNewLitter for offspring update not found.");
    });

    await t.step("should return an error if offspring not found", async () => {
      const result = await concept.updateOffspring({ offspringId: createBrandedId("nonExistentOffspring"), sex: Sex.Neuter });
      assertExists(result.error);
      assertEquals(result.error, "Offspring with ID nonExistentOffspring not found.");
    });
  });

  await t.step("recordWeaning action", async (t) => {
    let litterId: ID;
    let aliveOffspringId: ID;
    let deceasedOffspringId: ID;
    let alreadyWeanedOffspringId: ID;

    await t.step("setup: record litter and offspring", async () => {
      const mother11 = createBrandedId("mother11");
      await concept.addMother({ motherId: mother11 });
      const litterResult = await concept.recordLitter({
        motherId: mother11,
        birthDate: new Date("2023-05-01"),
        reportedLitterSize: 3,
      });
      assertExists(litterResult.litter);
      litterId = litterResult.litter._id;

      aliveOffspringId = createBrandedId("offspringAlive");
      await concept.recordOffspring({ litterId, offspringId: aliveOffspringId, sex: Sex.Male });

      deceasedOffspringId = createBrandedId("offspringDeceased");
      await concept.recordOffspring({ litterId, offspringId: deceasedOffspringId, sex: Sex.Female });
      await concept.recordDeath({ offspringId: deceasedOffspringId });

      alreadyWeanedOffspringId = createBrandedId("offspringWeaned");
      await concept.recordOffspring({ litterId, offspringId: alreadyWeanedOffspringId, sex: Sex.Neuter });
      await concept.recordWeaning({ offspringId: alreadyWeanedOffspringId });
    });

    await t.step("should set `survivedTillWeaning` to true for an alive offspring", async () => {
      const result = await concept.recordWeaning({ offspringId: aliveOffspringId });
      assertEquals(result.offspringId, aliveOffspringId);

      const offspring = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(aliveOffspringId) });
      assertExists(offspring);
      assertEquals(offspring.survivedTillWeaning, true);
    });

    await t.step("should return an error if offspring is not alive", async () => {
      const result = await concept.recordWeaning({ offspringId: deceasedOffspringId });
      assertExists(result.error);
      assertEquals(result.error, `Offspring with ID ${deceasedOffspringId} is not alive and cannot be weaned.`);
    });

    await t.step("should return an error if offspring is already weaned", async () => {
      const result = await concept.recordWeaning({ offspringId: alreadyWeanedOffspringId });
      assertExists(result.error);
      assertEquals(result.error, `Offspring with ID ${alreadyWeanedOffspringId} is already marked as weaned.`);
    });

    await t.step("should return an error if offspring not found", async () => {
      const result = await concept.recordWeaning({ offspringId: createBrandedId("nonExistentWeaning") });
      assertExists(result.error);
      assertEquals(result.error, "Offspring with ID nonExistentWeaning not found.");
    });
  });

  await t.step("recordDeath action", async (t) => {
    let litterId: ID;
    let aliveOffspringId: ID;
    let deceasedOffspringId: ID;

    await t.step("setup: record litter and offspring", async () => {
      const mother12 = createBrandedId("mother12");
      await concept.addMother({ motherId: mother12 });
      const litterResult = await concept.recordLitter({
        motherId: mother12,
        birthDate: new Date("2023-06-01"),
        reportedLitterSize: 2,
      });
      assertExists(litterResult.litter);
      litterId = litterResult.litter._id;

      aliveOffspringId = createBrandedId("offspringAliveForDeath");
      await concept.recordOffspring({ litterId, offspringId: aliveOffspringId, sex: Sex.Male });

      deceasedOffspringId = createBrandedId("offspringDeceasedAlready");
      await concept.recordOffspring({ litterId, offspringId: deceasedOffspringId, sex: Sex.Female });
      await concept.recordDeath({ offspringId: deceasedOffspringId });
    });

    await t.step("should set `isAlive` to false for an alive offspring", async () => {
      const result = await concept.recordDeath({ offspringId: aliveOffspringId });
      assertEquals(result.offspringId, aliveOffspringId);

      const offspring = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(aliveOffspringId) });
      assertExists(offspring);
      assertEquals(offspring.isAlive, false);
    });

    await t.step("should return an error if offspring is already deceased", async () => {
      const result = await concept.recordDeath({ offspringId: deceasedOffspringId });
      assertExists(result.error);
      assertEquals(result.error, `Offspring with ID ${deceasedOffspringId} is already marked as deceased.`);
    });

    await t.step("should return an error if offspring not found", async () => {
      const result = await concept.recordDeath({ offspringId: createBrandedId("nonExistentDeath") });
      assertExists(result.error);
      assertEquals(result.error, "Offspring with ID nonExistentDeath not found.");
    });
  });

  await t.step("viewLittersOfMother action", async (t) => {
    const motherIdWithLitters: ID = createBrandedId("motherWithLitters");
    const motherIdNoLitters: ID = createBrandedId("motherNoLitters");
    let litterId1: ID, litterId2: ID;

    await t.step("setup: record mothers and litters", async () => {
      await concept.addMother({ motherId: motherIdWithLitters });
      await concept.addMother({ motherId: motherIdNoLitters });

      const res1 = await concept.recordLitter({
        motherId: motherIdWithLitters,
        birthDate: new Date("2023-07-01"),
        reportedLitterSize: 4,
      });
      litterId1 = res1.litter!._id;

      const res2 = await concept.recordLitter({
        motherId: motherIdWithLitters,
        birthDate: new Date("2023-07-15"),
        reportedLitterSize: 3,
      });
      litterId2 = res2.litter!._id;
    });

    await t.step("should return all litters for a mother with litters", async () => {
      const result = await concept.viewLittersOfMother({ motherId: motherIdWithLitters });
      assertExists(result.litters);
      assertEquals(result.litters.length, 2);
      assertArrayIncludes(result.litters.map((l) => l._id), [litterId1, litterId2]);
    });

    await t.step("should return an empty array for a mother with no litters", async () => {
      const result = await concept.viewLittersOfMother({ motherId: motherIdNoLitters });
      assertExists(result.litters);
      assertEquals(result.litters.length, 0);
    });

    await t.step("should return an error if mother not found", async () => {
      const result = await concept.viewLittersOfMother({ motherId: createBrandedId("nonExistentMotherLitters") });
      assertExists(result.error);
      assertEquals(result.error, "Mother with ID nonExistentMotherLitters not found.");
    });
  });

  await t.step("viewOffspringOfLitter action", async (t) => {
    let litterIdWithOffspring: ID;
    let litterIdNoOffspring: ID;
    let offspringId1: ID, offspringId2: ID;

    await t.step("setup: record litters and offspring", async () => {
      const mother13 = createBrandedId("mother13");
      const mother14 = createBrandedId("mother14");
      await concept.addMother({ motherId: mother13 });
      await concept.addMother({ motherId: mother14 });

      const res1 = await concept.recordLitter({
        motherId: mother13,
        birthDate: new Date("2023-08-01"),
        reportedLitterSize: 2,
      });
      litterIdWithOffspring = res1.litter!._id;

      const res2 = await concept.recordLitter({
        motherId: mother14,
        birthDate: new Date("2023-08-05"),
        reportedLitterSize: 0,
      });
      litterIdNoOffspring = res2.litter!._id;

      offspringId1 = createBrandedId("offspringA");
      await concept.recordOffspring({
        litterId: litterIdWithOffspring,
        offspringId: offspringId1,
        sex: Sex.Female,
      });
      offspringId2 = createBrandedId("offspringB");
      await concept.recordOffspring({
        litterId: litterIdWithOffspring,
        offspringId: offspringId2,
        sex: Sex.Male,
      });
    });

    await t.step("should return all offspring for a litter with offspring", async () => {
      const result = await concept.viewOffspringOfLitter({ litterId: litterIdWithOffspring });
      assertExists(result.offspring);
      assertEquals(result.offspring.length, 2);
      assertArrayIncludes(result.offspring.map((o) => o._id), [offspringId1, offspringId2]);
    });

    await t.step("should return an empty array for a litter with no offspring", async () => {
      const result = await concept.viewOffspringOfLitter({ litterId: litterIdNoOffspring });
      assertExists(result.offspring);
      assertEquals(result.offspring.length, 0);
    });

    await t.step("should return an error if litter not found", async () => {
      const result = await concept.viewOffspringOfLitter({ litterId: createBrandedId("nonExistentLitterOffspring") });
      assertExists(result.error);
      assertEquals(result.error, "Litter with ID nonExistentLitterOffspring not found.");
    });
  });

  await t.step("generateReport action", async (t) => {
    const motherA = createBrandedId("reportMotherA");
    const motherB = createBrandedId("reportMotherB");
    const motherC = createBrandedId("reportMotherC"); // Mother with no litters in range
    const startDate = new Date("2023-01-01T00:00:00.000Z");
    const endDate = new Date("2023-12-31T23:59:59.999Z");

    await t.step("setup: create data for report generation", async () => {
      await concept.addMother({ motherId: motherA });
      await concept.addMother({ motherId: motherB });
      await concept.addMother({ motherId: motherC });

      // Mother A: Two litters, 2 weaned, 1 death
      const litterA1_id = (await concept.recordLitter({
        motherId: motherA,
        birthDate: new Date("2023-03-01"),
        reportedLitterSize: 3,
      })).litter!._id;
      const offspringA1_O1 = createBrandedId("A1_O1");
      const offspringA1_O2 = createBrandedId("A1_O2");
      const offspringA1_O3 = createBrandedId("A1_O3");
      await concept.recordOffspring({ litterId: litterA1_id, offspringId: offspringA1_O1, sex: Sex.Male });
      await concept.recordOffspring({ litterId: litterA1_id, offspringId: offspringA1_O2, sex: Sex.Female });
      await concept.recordOffspring({ litterId: litterA1_id, offspringId: offspringA1_O3, sex: Sex.Neuter });
      await concept.recordWeaning({ offspringId: offspringA1_O1 });
      await concept.recordWeaning({ offspringId: offspringA1_O2 });
      await concept.recordDeath({ offspringId: offspringA1_O3 }); // 2 weaned, 1 deceased

      const litterA2_id = (await concept.recordLitter({
        motherId: motherA,
        birthDate: new Date("2023-06-15"),
        reportedLitterSize: 2,
      })).litter!._id;
      const offspringA2_O1 = createBrandedId("A2_O1");
      const offspringA2_O2 = createBrandedId("A2_O2");
      await concept.recordOffspring({ litterId: litterA2_id, offspringId: offspringA2_O1, sex: Sex.Male });
      await concept.recordOffspring({ litterId: litterA2_id, offspringId: offspringA2_O2, sex: Sex.Female });
      await concept.recordWeaning({ offspringId: offspringA2_O1 }); // 1 weaned, 1 still alive not weaned

      // Mother B: One litter, 1 weaned, 0 death
      const litterB1_id = (await concept.recordLitter({
        motherId: motherB,
        birthDate: new Date("2023-09-01"),
        reportedLitterSize: 2,
      })).litter!._id;
      const offspringB1_O1 = createBrandedId("B1_O1");
      const offspringB1_O2 = createBrandedId("B1_O2");
      await concept.recordOffspring({ litterId: litterB1_id, offspringId: offspringB1_O1, sex: Sex.Male });
      await concept.recordOffspring({ litterId: litterB1_id, offspringId: offspringB1_O2, sex: Sex.Female });
      await concept.recordWeaning({ offspringId: offspringB1_O1 });
      // B1_O2 is alive but not weaned, not deceased
    });

    await t.step("should generate a report with correct overall and per-mother metrics", async () => {
      const targetMothers = [motherA, motherB, motherC];
      const reportName = "TestReproductionReport";
      const result = await concept.generateReport({ target: targetMothers, startDateRange: startDate, endDateRange: endDate, name: reportName });

      assertExists(result.report);
      assertEquals(result.report.reportName, reportName);
      assertEquals(result.report.target, targetMothers); // Target IDs are branded strings in DTO
      assertExists(result.report.dateGenerated);

      const results = result.report.results;
      // Overall metrics
      assertEquals(results.motherCount, 3); // A, B, C
      assertEquals(results.uniqueLittersRecorded, 3); // A1, A2, B1
      assertEquals(results.totalReportedLitterSize, 3 + 2 + 2); // A1:3, A2:2, B1:2 = 7
      assertEquals(results.totalActualOffspringBorn, 3 + 2 + 2); // A1:3, A2:2, B1:2 = 7
      assertEquals(results.totalWeanedOffspring, 2 + 1 + 1); // A1:2, A2:1, B1:1 = 4
      assertEquals(results.totalDeceasedOffspring, 1); // A1:1

      assertEquals(results.averageReportedLitterSize, parseFloat((7 / 3).toFixed(2))); // 7 / 3 litters = 2.33
      assertEquals(results.averageActualOffspringPerLitter, parseFloat((7 / 3).toFixed(2))); // 7 / 3 litters = 2.33
      assertEquals(results.survivabilityRateToWeaning, parseFloat((4 / 7 * 100).toFixed(2)) + "%"); // 4 weaned / 7 born = 57.14%

      // Per-Mother Metrics
      assertExists(results.perMotherPerformance);
      assertEquals(results.perMotherPerformance.length, 3);

      const motherA_perf = results.perMotherPerformance.find(p => p.motherId === motherA);
      assertExists(motherA_perf);
      assertEquals(motherA_perf.littersRecorded, 2);
      assertEquals(motherA_perf.totalOffspringBorn, 5); // 3 from A1 + 2 from A2
      assertEquals(motherA_perf.totalOffspringWeaned, 3); // 2 from A1 + 1 from A2
      assertEquals(motherA_perf.totalDeceasedOffspring, 1); // 1 from A1
      assertEquals(motherA_perf.weaningSurvivabilityRate, parseFloat((3 / 5 * 100).toFixed(2)) + "%"); // 60.00%
      assertEquals(motherA_perf.averageActualOffspringPerLitter, parseFloat((5 / 2).toFixed(2))); // 2.50

      const motherB_perf = results.perMotherPerformance.find(p => p.motherId === motherB);
      assertExists(motherB_perf);
      assertEquals(motherB_perf.littersRecorded, 1);
      assertEquals(motherB_perf.totalOffspringBorn, 2);
      assertEquals(motherB_perf.totalOffspringWeaned, 1);
      assertEquals(motherB_perf.totalDeceasedOffspring, 0);
      assertEquals(motherB_perf.weaningSurvivabilityRate, parseFloat((1 / 2 * 100).toFixed(2)) + "%"); // 50.00%
      assertEquals(motherB_perf.averageActualOffspringPerLitter, parseFloat((2 / 1).toFixed(2))); // 2.00

      const motherC_perf = results.perMotherPerformance.find(p => p.motherId === motherC);
      assertExists(motherC_perf);
      assertEquals(motherC_perf.littersRecorded, 0);
      assertEquals(motherC_perf.totalOffspringBorn, 0);
      assertEquals(motherC_perf.totalOffspringWeaned, 0);
      assertEquals(motherC_perf.totalDeceasedOffspring, 0);
      assertEquals(motherC_perf.weaningSurvivabilityRate, "0.00%");
      assertEquals(motherC_perf.averageActualOffspringPerLitter, 0);

      const storedReport = await db.collection(PREFIX + "generatedReports").findOne({ reportName });
      assertExists(storedReport);
      assertEquals(storedReport.reportName, reportName);
    });

    await t.step("should return an error if a target mother does not exist", async () => {
      const result = await concept.generateReport({
        target: [createBrandedId("nonExistentMother")],
        startDateRange: startDate,
        endDateRange: endDate,
      });
      assertExists(result.error);
      assertEquals(result.error, "One or more target IDs are not registered mothers: nonExistentMother.");
    });

    await t.step("should return an error if report name already exists", async () => {
      const existingReportName = "DuplicateReportName";
      await concept.generateReport({ target: [motherA], startDateRange: startDate, endDateRange: endDate, name: existingReportName });
      const result = await concept.generateReport({ target: [motherA], startDateRange: startDate, endDateRange: endDate, name: existingReportName });
      assertExists(result.error);
      assertEquals(result.error, `Report with name '${existingReportName}' already exists.`);
    });
  });

  await t.step("renameReport action", async (t) => {
    const oldName = "ReportToRename";
    const newName = "RenamedReport";
    const conflictName = "ConflictingReport";
    let reportId: ID;

    await t.step("setup: create reports", async () => {
      const motherRename = createBrandedId("motherRename");
      await concept.addMother({ motherId: motherRename });
      const reportResult = await concept.generateReport({
        target: [motherRename],
        startDateRange: new Date("2023-01-01"),
        endDateRange: new Date("2023-01-01"),
        name: oldName,
      });
      reportId = reportResult.report!._id; // DTO._id is branded string

      await concept.generateReport({
        target: [motherRename],
        startDateRange: new Date("2023-01-02"),
        endDateRange: new Date("2023-01-02"),
        name: conflictName,
      });
    });

    await t.step("should rename an existing report", async () => {
      const result = await concept.renameReport({ oldName, newName });
      assertExists(result.report);
      assertEquals(result.report._id, reportId);
      assertEquals(result.report.reportName, newName);

      const renamedReport = await db.collection(PREFIX + "generatedReports").findOne({ _id: brandedIdToObjectId(reportId) });
      assertExists(renamedReport);
      assertEquals(renamedReport.reportName, newName);

      const oldReport = await db.collection(PREFIX + "generatedReports").findOne({ reportName: oldName });
      assertEquals(oldReport, null);
    });

    await t.step("should return an error if old report name does not exist", async () => {
      const result = await concept.renameReport({ oldName: "NonExistentReport", newName: "NewName" });
      assertExists(result.error);
      assertEquals(result.error, "Report with name 'NonExistentReport' not found.");
    });

    await t.step("should return an error if new report name already exists", async () => {
      const result = await concept.renameReport({ oldName: newName, newName: conflictName });
      assertExists(result.error);
      assertEquals(result.error, `Report with new name '${conflictName}' already exists.`);
    });
  });

  await t.step("viewReport action", async (t) => {
    const reportName = "ViewableReport";
    let reportId: ID;

    await t.step("setup: create a report", async () => {
      const motherView = createBrandedId("motherView");
      await concept.addMother({ motherId: motherView });
      const reportResult = await concept.generateReport({
        target: [motherView],
        startDateRange: new Date("2023-01-01"),
        endDateRange: new Date("2023-01-01"),
        name: reportName,
      });
      reportId = reportResult.report!._id;
    });

    await t.step("should return the full report details", async () => {
      const result = await concept.viewReport({ reportName });
      assertExists(result.report);
      assertEquals(result.report._id, reportId);
      assertEquals(result.report.reportName, reportName);
      assertExists(result.report.results);
    });

    await t.step("should return an error if report not found", async () => {
      const result = await concept.viewReport({ reportName: "NonExistentViewReport" });
      assertExists(result.error);
      assertEquals(result.error, "Report with name 'NonExistentViewReport' not found.");
    });
  });

  await t.step("listReports action", async (t) => {
    await t.step("setup: create multiple reports", async () => {
      const motherList = createBrandedId("motherList");
      await concept.addMother({ motherId: motherList });
      await concept.generateReport({
        target: [motherList],
        startDateRange: new Date("2023-01-01"),
        endDateRange: new Date("2023-01-01"),
        name: "ListReport1",
      });
      await concept.generateReport({
        target: [motherList],
        startDateRange: new Date("2023-01-02"),
        endDateRange: new Date("2023-01-02"),
        name: "ListReport2",
      });
    });

    await t.step("should return all generated reports", async () => {
      const result = await concept.listReports();
      assertExists(result.reports);
      assertEquals(result.reports.length, 2);
      assertArrayIncludes(result.reports.map((r) => r.reportName), ["ListReport1", "ListReport2"]);
    });

    await t.step("should return an empty array if no reports exist", async () => {
      // After cleanup from other tests
      await db.collection(PREFIX + "generatedReports").deleteMany({});
      const result = await concept.listReports();
      assertEquals(result.reports.length, 0);
    });
  });

  await t.step("deleteReport action", async (t) => {
    const reportToDelete = "ReportToDelete";
    const reportToKeep = "ReportToKeep";

    await t.step("setup: create reports", async () => {
      const motherDelete = createBrandedId("motherDelete");
      await concept.addMother({ motherId: motherDelete });
      await concept.generateReport({
        target: [motherDelete],
        startDateRange: new Date("2023-01-01"),
        endDateRange: new Date("2023-01-01"),
        name: reportToDelete,
      });
      await concept.generateReport({
        target: [motherDelete],
        startDateRange: new Date("2023-01-02"),
        endDateRange: new Date("2023-01-02"),
        name: reportToKeep,
      });
    });

    await t.step("should delete an existing report", async () => {
      const result = await concept.deleteReport({ reportName: reportToDelete });
      assertEquals(result, {}); // Empty object on success

      const deletedReport = await db.collection(PREFIX + "generatedReports").findOne({ reportName: reportToDelete });
      assertEquals(deletedReport, null);

      const keptReport = await db.collection(PREFIX + "generatedReports").findOne({ reportName: reportToKeep });
      assertExists(keptReport);
    });

    await t.step("should return an error if report not found", async () => {
      const result = await concept.deleteReport({ reportName: "NonExistentDeleteReport" });
      assertExists(result.error);
      assertEquals(result.error, "Report with name 'NonExistentDeleteReport' not found.");
    });
  });

  await t.step("aiSummary action", async (t) => {
    const motherAI = createBrandedId("motherAISummary");
    const reportName = "AISummaryReport";
    const startDate = new Date("2023-01-01T00:00:00.000Z");
    const endDate = new Date("2023-12-31T23:59:59.999Z");

    await t.step("setup: create data and a report", async () => {
      await concept.addMother({ motherId: motherAI });
      const litterAI1_id = (await concept.recordLitter({
        motherId: motherAI,
        birthDate: new Date("2023-04-01"),
        reportedLitterSize: 5,
      })).litter!._id;
      const offspringAI_O1 = createBrandedId("AI_O1");
      const offspringAI_O2 = createBrandedId("AI_O2");
      const offspringAI_O3 = createBrandedId("AI_O3");
      const offspringAI_O4 = createBrandedId("AI_O4");
      const offspringAI_O5 = createBrandedId("AI_O5");

      await concept.recordOffspring({ litterId: litterAI1_id, offspringId: offspringAI_O1, sex: Sex.Male });
      await concept.recordOffspring({ litterId: litterAI1_id, offspringId: offspringAI_O2, sex: Sex.Female });
      await concept.recordOffspring({ litterId: litterAI1_id, offspringId: offspringAI_O3, sex: Sex.Neuter });
      await concept.recordOffspring({ litterId: litterAI1_id, offspringId: offspringAI_O4, sex: Sex.Male });
      await concept.recordOffspring({ litterId: litterAI1_id, offspringId: offspringAI_O5, sex: Sex.Female });

      await concept.recordWeaning({ offspringId: offspringAI_O1 });
      await concept.recordWeaning({ offspringId: offspringAI_O2 });
      await concept.recordDeath({ offspringId: offspringAI_O3 });
      await concept.recordWeaning({ offspringId: offspringAI_O4 }); // 4 weaned, 1 death, 1 not weaned but alive

      await concept.generateReport({
        target: [motherAI],
        startDateRange: startDate,
        endDateRange: endDate,
        name: reportName,
      });
    });

    await t.step("should return an error if GEMINI_API_KEY is not set", async () => {
      const originalApiKey = Deno.env.get("GEMINI_API_KEY");
      Deno.env.delete("GEMINI_API_KEY"); // Temporarily unset
      try {
        const result = await concept.aiSummary({ reportName });
        assertExists(result.error);
        assertEquals(result.error, "GEMINI_API_KEY environment variable is not set.");
      } finally {
        if (originalApiKey) {
          Deno.env.set("GEMINI_API_KEY", originalApiKey); // Restore
        }
      }
    });

    await t.step("should return an error if report not found", async () => {
      const result = await concept.aiSummary({ reportName: "NonExistentAISummary" });
      assertExists(result.error);
      assertEquals(result.error, "Report with name 'NonExistentAISummary' not found.");
    });

    await t.step("should generate a valid JSON summary if API key is set", {
      // This test is conditional on the API key existing.
      // If it doesn't exist, the previous test case covers the error.
      // If it does, we expect a valid JSON response.
      skip: !Deno.env.get("GEMINI_API_KEY"),
    }, async () => {
      const result = await concept.aiSummary({ reportName });
      assertExists(result.summary, "Expected an AI summary to be generated.");
      assertNotEquals(result.summary.length, 0, "Summary should not be empty.");

      // Attempt to parse the summary to ensure it's valid JSON
      let parsedSummary;
      try {
        parsedSummary = JSON.parse(result.summary);
      } catch (e) {
        throw new Error(`AI summary was not valid JSON: ${e.message}\nSummary: ${result.summary}`);
      }

      // Check for expected top-level keys in the parsed JSON
      const expectedKeys = [
        "highPerformers",
        "lowPerformers",
        "concerningTrends",
        "averagePerformers",
        "potentialRecordErrors",
        "insights",
      ];
      assert(
        expectedKeys.every(key => key in parsedSummary),
        `AI summary missing expected keys: ${
          expectedKeys.filter(key => !(key in parsedSummary)).join(", ")
        }`,
      );
      assert(Array.isArray(parsedSummary.highPerformers));
      assert(typeof parsedSummary.insights === "string");
    });
  });

  await t.step("# trace: Principle Fulfillment", async (t) => {
    // purpose: track reproductive outcomes and offspring survivability for breeding animals, organizing individual offspring into distinct litters.
    // principle: a user records birth events by first creating a litter for a mother animal, optionally linking a father and setting an expected litter size;
    // then, individual offspring born to that litter are recorded and linked to it;
    // later records weaning outcomes for those offspring when the data becomes available;
    // uses this data to generate reports to evaluate reproductive performance and inform breeding decisions, including litter-specific metrics;
    // can choose to generate an AI summary of generated reports to aide in understanding and decision making;

    const motherId: ID = createBrandedId("PrincipleMother1");
    const fatherId: ID = createBrandedId("PrincipleFather1");
    const litterBirthDate = new Date("2023-01-01T10:00:00Z");
    const reportedSize = 4;
    const reportName = "PrincipleReport";
    const startDate = new Date("2022-12-01T00:00:00Z");
    const endDate = new Date("2023-02-28T23:59:59Z");

    let litterId: ID; // This will hold the DTO._id (branded string)

    await t.step("1. User records birth events by creating a litter", async () => {
      const result = await concept.recordLitter({
        motherId,
        fatherId,
        birthDate: litterBirthDate,
        reportedLitterSize: reportedSize,
        notes: "First litter of PrincipleMother1",
      });
      assertExists(result.litter);
      litterId = result.litter._id; // Store branded string
      assertEquals(result.litter.motherId, motherId);
      assertEquals(result.litter.reportedLitterSize, reportedSize);

      // Check raw DB entry
      const mother = await db.collection(PREFIX + "mothers").findOne({ _id: brandedIdToObjectId(motherId) });
      assertExists(mother, "Mother should have been added implicitly.");
    });

    await t.step("2. Individual offspring born to that litter are recorded", async () => {
      const off1Id = createBrandedId("Off1");
      const off2Id = createBrandedId("Off2");
      const off3Id = createBrandedId("Off3");
      const off4Id = createBrandedId("Off4");

      await concept.recordOffspring({ litterId, offspringId: off1Id, sex: Sex.Male });
      await concept.recordOffspring({ litterId, offspringId: off2Id, sex: Sex.Female });
      await concept.recordOffspring({ litterId, offspringId: off3Id, sex: Sex.Female });
      await concept.recordOffspring({ litterId, offspringId: off4Id, sex: Sex.Male });

      // Query raw DB, convert litterId to ObjectId
      const offspringInLitter = await db.collection(PREFIX + "offspring").find({ litterId: brandedIdToObjectId(litterId) }).toArray();
      assertEquals(offspringInLitter.length, 4);
      assertEquals(offspringInLitter.filter(o => o.isAlive).length, 4);
      assertEquals(offspringInLitter.filter(o => !o.survivedTillWeaning).length, 4);
    });

    await t.step("3. Later records weaning outcomes for those offspring", async () => {
      await concept.recordWeaning({ offspringId: createBrandedId("Off1") });
      await concept.recordWeaning({ offspringId: createBrandedId("Off2") });
      await concept.recordDeath({ offspringId: createBrandedId("Off3") }); // Died before weaning

      const off1 = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(createBrandedId("Off1")) });
      assertExists(off1);
      assertEquals(off1.survivedTillWeaning, true);

      const off2 = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(createBrandedId("Off2")) });
      assertExists(off2);
      assertEquals(off2.survivedTillWeaning, true);

      const off3 = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(createBrandedId("Off3")) });
      assertExists(off3);
      assertEquals(off3.isAlive, false);
      assertEquals(off3.survivedTillWeaning, false); // Should not be weaned if died

      const off4 = await db.collection(PREFIX + "offspring").findOne({ _id: brandedIdToObjectId(createBrandedId("Off4")) });
      assertExists(off4);
      assertEquals(off4.isAlive, true);
      assertEquals(off4.survivedTillWeaning, false); // Still alive, not weaned
    });

    await t.step("4. Uses this data to generate reports to evaluate reproductive performance", async () => {
      const reportResult = await concept.generateReport({
        target: [motherId],
        startDateRange: startDate,
        endDateRange: endDate,
        name: reportName,
      });
      assertExists(reportResult.report);
      const results = reportResult.report.results;

      // Verify overall metrics
      assertEquals(results.uniqueLittersRecorded, 1);
      assertEquals(results.totalReportedLitterSize, reportedSize);
      assertEquals(results.totalActualOffspringBorn, 4);
      assertEquals(results.totalWeanedOffspring, 2); // Off1, Off2
      assertEquals(results.totalDeceasedOffspring, 1); // Off3

      assertEquals(results.averageReportedLitterSize, parseFloat((reportedSize / 1).toFixed(2))); // 4.00
      assertEquals(results.averageActualOffspringPerLitter, parseFloat((4 / 1).toFixed(2))); // 4.00
      assertEquals(results.survivabilityRateToWeaning, parseFloat((2 / 4 * 100).toFixed(2)) + "%"); // 50.00%

      // Verify per-mother metrics
      assertEquals(results.perMotherPerformance.length, 1);
      const motherPerf = results.perMotherPerformance[0];
      assertEquals(motherPerf.motherId, motherId);
      assertEquals(motherPerf.littersRecorded, 1);
      assertEquals(motherPerf.totalOffspringBorn, 4);
      assertEquals(motherPerf.totalOffspringWeaned, 2);
      assertEquals(motherPerf.totalDeceasedOffspring, 1);
      assertEquals(motherPerf.weaningSurvivabilityRate, parseFloat((2 / 4 * 100).toFixed(2)) + "%");
      assertEquals(motherPerf.averageActualOffspringPerLitter, parseFloat((4 / 1).toFixed(2)));
    });

    await t.step("5. Can choose to generate an AI summary of generated reports", {
      skip: !Deno.env.get("GEMINI_API_KEY"),
    }, async () => {
      const summaryResult = await concept.aiSummary({ reportName });
      assertExists(summaryResult.summary, "AI summary should be generated.");
      assertNotEquals(summaryResult.summary.length, 0, "AI summary should not be empty.");

      // Basic JSON validation as in the dedicated aiSummary test
      let parsedSummary;
      try {
        parsedSummary = JSON.parse(summaryResult.summary);
      } catch (e) {
        throw new Error(`AI summary in principle trace was not valid JSON: ${e.message}\nSummary: ${summaryResult.summary}`);
      }
      assertExists(parsedSummary.insights);
      assert(typeof parsedSummary.insights === "string");
      assert(Array.isArray(parsedSummary.highPerformers));
    });
  });
});
```
